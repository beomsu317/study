# 벽돌부터 시작하기: 프로그래밍 패러다임

## 패러다임 개요

### 구조적 프로그래밍

최초로 적용된 패러다임. 순차(sequence), 분기(selection), 반복(iteration) 세 가지 구조. 구조적 프로그래밍이 현재까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는
능력 때문이다. 또한 아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여기기 때문이기도 하다.

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들어야 한다.

> 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍

알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 후에도 함수에서 선언된 지역 변수가 오래 유지될 수 있음이 발견되었으며, 이것이 클래스의 생성자가 되었고, 지역 변수는 인스턴스
변수, 중첩 함수는 메서드가 되었다.

OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있으며, 이것이 바로 OO가 제공하는 힘이며, 아키텍트 관점에서 OO가 지향하는 것이다.

이를 이용해 디비와 UI에 의존하는 대신, 시스템의 소스 코드 의존성을 반대로 배치하여 디비와 UI가 Business rule에 의존하게 만들 수 있다. 즉, UI와 디비가 Business rule의 플러그인이
된다는 의미이다. 다시 말하면 Business rule의 소스 코드에서 UI나 디비를 호출하지 않는다.

이렇게 3가지로 분리된 컴포넌트로 컴파일할 수 있고, 이 배포 단위들의 의존성 역시 소스 코드 사이 의존성과 같다. 따라서 Business rule을 UI와 디비와 독립적으로 배포할 수 있다. UI나 디비에서 발생한
변경사항은 Business rule에 영향을 미치지 않는다. 즉, 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 바로 배포 독립성(independent
deployability)이다. 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 각 모듈을 독립적으로 개발할 수 있다. 이는 개발 독립성(independent developability)이다.

> 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍

람다 계산법의 기초는 불변성으로 심볼의 값이 변경되지 않는다는 개념이다. 이는 함수형 언어에 할다문이 전혀 없다는 의미이기도 하다.

함수형 프로그래밍의 기반은 람다 계산법이다.

Race condition, deadlock, concurrent update 문제는 모두 가변 변수로 인해 발생된다. 만약 어떠한 변수도 갱신되지 않는다면 이러한 문제가 발생하지 않는다.

가변성을 분리하기 위해 앱 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리한다. 불변 컴포넌트는 순수 함수로만 작업이 처리되며, 가변 변수를 사용하지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는 순수
함수 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 통신한다. 상태 변경은 트랜잭션 메모리와 같은 방법을 통해 race condition과 concurrent update 문제로부터 가변 변수를 보호한다.

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

