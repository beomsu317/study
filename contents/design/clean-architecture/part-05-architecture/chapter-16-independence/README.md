# Independence

좋은 아키텍터는 다음을 지원해야 한다.

* 시스템의 유스케이스
* 시스템의 운영
* 시스템의 개발
* 시스템의 배포

## 유스케이스

유스케이스의 경우 시스템 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다. 만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 한다.

좋은 아키텍처가 행위를 지원하기 위한 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있도록 만드는 것이다.

## 운영

시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답시간을 보장해야 한다.

이러한 형태를 지원한다는 말은 여러 의미를 지닌다. 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야 함을 의미한다. 또 다른 시스템에서는 경량의 수많은
스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다는 뜻일 수도 있다. 또는 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템도 있을 것이다.

아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한한지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를
전환하는 일이 훨씬 쉬워질 것이다.

## 개발

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다.

## 배포

배포 용이성을 결정하는데 중요한 역할을 한다. 목표는 `즉각적인 배포`다. 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다. 여기에는 마스터(master) 컴포넌트도 포함되며, 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게
구동하고 통합하고 관리해야 한다.

## 선택사항 열어놓기

일부 아키텍처 원칙은 구현하는 비용이 비교적 비싸지 않으며, 관심사들 사이에서 균형을 잡는 데 도움이 된다. 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한
많이, 오랫동안 열어 둘 수 있게 해준다. 이를 통해 향후 시스템 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리

아키텍트는 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지 못한다. 하지만 시스템의 기본적인 의도는 분명히 알고 있다. 따라서 SRP, CCP를 적용해 다른 이유로 변경되는 것들은
분리하고, 동일한 이유로 변경되는 것들을 묶는다.

데이터베이스, 쿼리 언어, 심지어 스키마조차도 세부사항이며 업무 규칙이나 UI와는 아무 관련이 없다. 아키텍트는 이들을 시스템의 나머지 부분으로 분리하여 독립적으로 변경할 수 있도록 해야 한다. 이제 시스템을 서로
결합되지 않은 수평적인 계층으로 분리하는 방법을 알게 되었다.

## 유스케이스 결합 분리

주문 추가 유스케이스와 주문 삭제 유스케이스는 다른 이유로 변경된다. 따라서 유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.

각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스의 기능의 일부를 사용한다. 따라서 시스템을 수평적 계층으로 분할하며 동시에 해당 계층을
가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.

이와 같이 결합을 분리하려면 주문 추가 유스케이스 UI와 주문 삭제 유스케이스의 UI를 분리해야 한다. 유스케이스 업무 규칙과 데이터베이스 부분도 마찬가지이다.

## 결합 분리 모드

이렇게 결합을 분리하면 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다. UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무
규칙과 다른 서버에서 실행될 수 있다. 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다. 다시 말해 유스케이스를 위해 수행하는 그 작업들(결합 분리)은 운영에 도움이 된다. 때때로 컴포넌트를
서비스 수준까지도 분리해야 한다.

## 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이 간섭은 줄어든다. UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 영향을 줄 수 없으며, 유스케이스 자체도 결합이 분리되면 addOrder 유스케이스에
중점을 둔 팀이 deleteOrder 유스케이스 중점을 둔 팀에 개입할 가능성은 거의 없다.

## 배포 독립성

유스케이스와 계층 결합이 분리되면 배포 측면에서도 유연성이 생긴다. 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)할 수 있다.

## 중복

중복에는 여러 종류가 있다.

* 진짜 중복: 이 경우 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.
* 우발적 중복: 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다. 몇 년 지나 다시 보면 두 코드가 매우 다른 사실을 알 수 있다.

예를 들어 두 유스케이스의 화면 구조가 매우 비슷하다고 가정해보자. 이는 우발적 중복을 가능성이 높다. 시간이 지나면 두 화면은 서로 다른 방향으로 분기하며, 결국 매우 다른 모습을 가질 가능성이 높다. 이런 경우
해당 코드를 통합하지 않도록 유의해야 한다. 그렇지 않으면 나중에 코드를 다시 분리하느라 큰 수고를 감수해야 한다.

## 결합 분리 모드

계층과 유스케이스의 결합을 분리하는 방법은 다양하다. 소스 코드 수준에서 분리할 수도 있으며, 바이너리 코드(배포) 수준에서도, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.

* 소스 수준 분리 모드: 소스 코드 모듈 사이 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈이 변경하거나 재컴파일하지 않도록 만들 수 있다.
* 배포 수준 분리 모드: .jar, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이 의존성을 제어할 수 있다. 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들
  수 있다. 이 모드의 중요한 특징은 결합이 분리된 컴포넌트가 jar 파일, Gem 파일, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할되어 있다는 점이다.
* 서비스 수준 분리 모드: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로
  완전히 독립적이게 된다.
    * 예) 서비스 또는 마이크로 서비스

프로젝트 초기 단계에는 어떤 모드가 최선인지 알기 어렵다. 프로젝트가 커질수록 최적인 모드가 달라질 수 있다.

한 가지 해결책은 단순히 서비스 수준에서의 분리를 기본 정책으로 가져가는 것이다. 하지만 이 방식은 비용이 많이 들고, 결합이 큰 단위(coarse-grained)에서 분리되는 문제가 있다. 또한 시스템 자원
측면에서도 비용이 많이 들게 된다.

이 방식을 사용하면 초기에 컴포넌트가 소스 코드 수준에서 분리된다. 개발, 배포, 운영적인 문제가 증가하면 서비스 수준으로 전환할 배포 단위들을 신중하게 선택한 후, 점차적으로(즉, 서비스화 하는 방향으로) 시스템을
변경해 나간다. 시간이 흐르면 운영 요구사항은 감소할 수 있다. 한 때는 서비스 수준까지 분리해야 했던 것들이 이제 배포 수준, 소스 수준의 결합 분리만으로 충분할 수 있다.

좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호하며, 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 해준다.

## 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬운데, 뛰어난 아키텍트라면 변경들을 예측하여 큰 무리 없이 반영할 수 있게 만들어야 한다.
