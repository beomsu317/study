# WHAT IS ARCHITECTURE?

소프트웨어 시스템의 아키테처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이다. 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라
정해진다. 또한 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 우영, 유지보수되도록 만들어진다.

> 이러한 일을 용이하게 만들기 위해 가능한 많은 선택지를, 가능한 오래 남겨두는 전략을 따라야 한다.

아키텍처의 주 목적은 시스템 생명주기를 지원하는 것이다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

## 개발

시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야 한다.

팀 구조가 다르면 아키텍처 결정에서도 차이가 난다. 팀 5명으로 구성될 정도로 작다면 잘 정의된 컴포넌트나 인터페이스가 없어도 효율적으로 모노리틱 시스템을 개발할 수 있다. 반대로 7명으로 구성된 5개의 팀이
시스템을 개발한다면 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리해야(각 팀마다 하나씩) 발전될 가능성이 높다.

## 배포

배포 비용이 높을수록 시스템 유용성을 떨어지기 때문에, 소프트웨어 아티텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 목표를 두어야 한다.

예를 들어 개발 초기 단계에 `마이크로 서비스 아키텍처`를 사용하자고 결정하면, 컴포넌트 경계가 뚜렸해지고 인터페이스가 대체로 안정화되므로 시스템을 쉽게 개발할 수 있다고 판단했을 것이다. 하지만 배포 시기가 되면
늘어난 수많이 마이크로서비스를 발견하며, 이를 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 수 있다.

배포 문제를 초기에 고려했다면 이와 다르게 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합된 도구를 사용하여 상호 연결을 관리했을 것이다.

## 운영

아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 상대적으로 덜하다. 운영에서 겪는 대부분의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.

좋은 소프트웨어 아키텍처는 시스템을 운영하는데 필요한 요구를 알려준다. 달리 말하면 시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다고 할 수 있다. 아키텍처는 유스케이스, 기능, 시스템의 필수
행위를 일급(first-class) 엔티티로 격상시키고, 이들 요소가 개발자에게 주 목표로 인식되도록 해야 한다. 이를 통해 시스템을 이해하기 쉬워지며, 개발과 유지보수에 큰 도움이 된다.

## 유지보수

유지보수는 모든 측면에서 봤을 때 비용이 가장 많이 발생된다. 유지보수의 가장 큰 비용은 탐사(spelunking)와 이로 인한 위험부담에 있다. 탐사란 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때,
소프트웨어를 파헤쳐 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정하는데 드는 비용이다. 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재한다.

신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다.

## 선택사항 열어두기

소프트웨어는 두 종류의 가치, 즉 행위적 가치와 구조적 가치를 지니며, 소프트웨어를 부드럽게(soft) 만드는 것은 구조적 가치이기 때문에 더욱 중요하다. 소프트웨어를 부드럽게 유지하기 위해 선택사항을 가능한 많이,
오랫동안 열어 두는 것이다. 열어 둬야 할 선택사항은 중요치 않은 세부사항(detail)이다.

모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다.

* 정책(policy): 모든 업무 규칙과 업무 절차를 구체화한다. 시스템의 진정한 가치가 살아있는 곳이다.
* 세부사항(detail): 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에 영향을 미치지 않는다.
    * 예) 입축력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 이를 통해 세부사항을 결정하는 일을 미루거나 연기할 수 있게
된다.

* 개발 초기에 데이터베이스 시스템을 선택할 필요가 없다. 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안 된다.
* 개발 초기에 웹 서버를 선택할 필요가 없다. 고수준의 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안 된다.
* 개발 초기에 REST를 적용할 필요가 없다. 고수준의 정책은 외부로의 인터페이스에 대해 독립적이여야 하기 때문이다.
* 개발 초기에 의존성 주입 프레임워크를 적용할 필요가 없다. 고수준의 정책은 의존성을 해석하는 방식에 신경 써서는 안 된다.

세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다면 더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있다. 또한 다양한 실험을 시도해볼 수 있다. 고수준 정책이 데이터베이스와
독립적이라면 다양한 데이터베이스 후보를 두고 적용 가능성과 성능을 검토해볼 수 있다.

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

## 장치 독립성

예전에는 코드를 입출력 장치와 직접 결합하여 사용했으며, 코드는 장치 종속적이었다. 이러한 구현은 데이터의 무결성이 문제였다.

오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 프로그램은 운영체제의 서비스를 호출하여, 해당 서비스가 추상화된 레코드 장치를 처리한다. 그리고 오퍼레이터가 해당 추상 서비스를 어떤 장치에 연결해야
하는지를 운영체제에 알려주었다. 따라서 동일한 프로그램을 아무런 변경 없이 카드나 테이프에서 읽고 쓸 수 있게 되었다.

## 광고 우편

어떤 장치(세부사항)를 사용할지 전혀 모른 채, 고려하지 않고 프로그램을 작성하면, 이 형태는 정책을 세부사항으로부터 분리한다. 어떤 장치를 사용할지에 대한 결정을 연기시킬 수 있다.

## 물리적 주소 할당

시스템에서 고수준의 정책이 디스크(장치)의 물리적 구조로부터 독립되도록 구현했다. 디스크 드라이브 구조에 대한 결정사항을 애플리케이션으로부터 분리할 수 있게 되었다.

## 결론

좋은 아키텍트는 세부사항을 정책으로부터 신중히 가려내고, 정책이 세부사항과 결합되지 않도록 업격하게 분리하며, 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.
